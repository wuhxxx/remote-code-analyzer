/////////////////////////////////////////////////////////////////////
// CodePublisher.h - Publish code files                            //
// Version 1.0                                                     //
// Author: Hongxin WU                                              //
// Resources from Jim Fawcett, CSE687 Spring 2017                  //
// Object Oriented Design Spring 2017 Project 3                    //
/////////////////////////////////////////////////////////////////////

#include <string>
#include <fstream>
#include <algorithm>

#include "CodePublisher.h"
#include "../TypeTable/TypeTable.h"
#include "../TypeAnalyzer/TypeAnalyzer.h"
#include "../DependencyAnalyzer/DependencyAnalyzer.h"
#include "../DependencyAnalyzer/Graph.h"
#include "../FileSystem/FileSystem.h"
#include "../FileMgr/FileMgr.h"
#include "../DependencyAnalyzer/XmlWriter.h"


// Constructor
CodePublisher::CodePublisher(std::string path, std::vector<std::string> pattern) {
	TypeTable ttb;
	TypeAnalyzer taz;
	DependencyAnalyzer tda;
	if (tda.checkCommand(path, pattern) && tda.generatefilepath()) {
		if (taz.analyze(tda.getFilePathes(), ttb)) {
			tda.anaStart(ttb);
		}
	}
	filePathes = tda.getFilePathes();
	depGraph = tda.getGraph();
	targetPath = FileSystem::Path::getFullFileSpec(path);
	//std::cout << "\n  " << targetPath;
	//pubInfo = taz.getPubInfo();///

	XmlWriter writer;
	writer.indent();
	writer.start("head");
	std::string cssLink = "<link rel=\"stylesheet\" href=\"" + FileSystem::Path::getFullFileSpec("../zJsCssFiles/StyleSheet1.css") + "\"/>";
	std::string jsLink = "<script src = \"" + FileSystem::Path::getFullFileSpec("../zJsCssFiles/handleScope.js") + "\"></script>";
	writer.addBody(cssLink);
	writer.addBody(jsLink);
	writer.end();
	headElement = writer.xml();
}


// trigger the code publisher to generate html files
bool CodePublisher::go() {
	for (auto vertice = depGraph.begin(); vertice != depGraph.end(); vertice++) {
		std::string filename = (*vertice).value();
		std::string path = getPath(filename);

		preProcess(path, filename);
		std::string prologue = generatePrologue(filename);
		std::string dependencies = generateDependencies(*vertice);
		std::string preContent = generatePreContent(filename);

		std::ofstream out(targetPath + filename + ".html");
		if (out.fail()) {
			out.close();
			return false;
		}
		out << prologue << "<html>" << headElement << "\n";
		out << "<body>\n<h3>" + filename + "</h3>\n<hr />" << dependencies << "\n<hr />";
		out << preContent << "</body>\n</html>";
		out.close();
	}

	//open(fileToOpen)
	//ShellExecuteA(GetDesktopWindow(), "open", fileToOpen.c_str(), NULL, NULL, SW_SHOW);
	return true;
}
//std::cout << dependencies<<"\n";
//std::cout << "\n" << preContent << "\n";
//for (auto pair : pubInfo) {
//	std::cout << "\n filename: " << pair.first;
//	for (auto pa : pair.second) {
//		std::cout << "\n    -- startline: " << pa.first << "; endline: " << pa.second;
//	}
//}


// create html file for specific file and handle character < >
bool CodePublisher::preProcess(std::string filepath, std::string filename) {
	try {
		std::ifstream in(filepath);
		if (in.fail()) {
			in.close();
			return false;
		}
		std::ofstream out(targetPath + filename + ".html");
		if (out.fail()) {
			out.close();
			return false;
		}
		std::filebuf* inbuf = in.rdbuf();
		std::filebuf* outbuf = out.rdbuf();
		char c = inbuf->sbumpc();
		while (c != EOF) {
			if (c == '<') {//&lt;
				outbuf->sputc('&');
				outbuf->sputc('l');
				outbuf->sputc('t');
				outbuf->sputc(';');
			}
			else if (c == '>') {//&gt;
				outbuf->sputc('&');
				outbuf->sputc('g');
				outbuf->sputc('t');
				outbuf->sputc(';');
			}
			else {
				outbuf->sputc(c);
			}
			c = inbuf->sbumpc();
		}
		in.close();
		out.close();
		return true;
	}
	catch (std::exception& ex) {
		std::cout << "\n\n  " << ex.what();
		return false;
	}
}


// generate Prologue for specific file name
std::string CodePublisher::generatePrologue(std::string filename) {
	std::string res = "<!----------------------------------------------------------------------------\n";
	res += "   " + filename + ".html - html file generated by CodePublisher\n";
	res += "   Hongxin Wu, CSE687 - Object Oriented Design(Spring 2017) Project 3\n";
	res += "----------------------------------------------------------------------------->\n";
	return res;
}


// generate dependencies div block string for specific file
std::string CodePublisher::generateDependencies(ver vertex) {
	XmlWriter writer, h4;
	writer.indent();
	writer.start("div");
	writer.addAttribute("class", "indent");
	h4.start("h4").addBody("Dependencies:").end();
	writer.addBody(h4.xml());
	if (vertex.size() == 0) {
		writer.addBody("No dependency found!");
	}
	else {
		for (auto edge = vertex.begin(); edge != vertex.end(); edge++) {
			XmlWriter a;
			std::string depC = depGraph[edge->first].value();
			a.start("a");
			a.addAttribute("href", depC + ".html");
			a.addBody(depC);
			a.end();
			writer.addBody(a.xml());
		}
	}
	writer.end();
	return writer.xml();
}


// search the filePathes for specific file name and return file's path
std::string CodePublisher::getPath(std::string file) {
	for (auto ele : filePathes) {
		if (FileSystem::Path::getName(ele) == file) {
			return ele;
		}
	}
	return "";
}


// generate corresponding html files for specific cpp file
std::string CodePublisher::generatePreContent(std::string filename) {
	std::string res = "\n<pre>\n";
	std::ifstream in(targetPath + filename + ".html");
	if (in.fail()) {in.close(); return "";}
	std::filebuf* inbuf = in.rdbuf();
	char c = inbuf->sbumpc();
	while (c != EOF) {
		res += c;
		c = inbuf->sbumpc();
	}
	in.close();
	res += "\n</pre>\n";
	return res;
}


//// return a pair, both elements are vector of line count in descending order
//std::pair<std::vector<size_t>, std::vector<size_t>> CodePublisher::sortLines(std::string filename) {
//	std::vector<size_t> startLines;
//	std::vector<size_t> endLines;
//	auto search = pubInfo.find(filename);
//	if (search != pubInfo.end()) {
//		std::vector<std::pair<size_t, size_t>> lines = search->second;
//		for (auto line : lines) {
//			startLines.push_back(line.first);
//			endLines.push_back(line.second);
//		}
//		std::sort(startLines.begin(), startLines.end(), [](size_t a, size_t b) {
//			return b < a;
//		});
//		std::sort(endLines.begin(), endLines.end(), [](size_t a, size_t b) {
//			return b < a;
//		});
//	}
//	else {
//		startLines.push_back(0);
//		endLines.push_back(0);
//	}
//	return std::make_pair(startLines, endLines);
//}

#ifdef TEST_CODEPUB

int main() {
	//std::string path, std::vector<std::string> parttern
	std::string path = "../zSeverDir/";
	std::vector<std::string> pattern;
	pattern.push_back("*.cpp");
	pattern.push_back("*.h");
	CodePublisher tcp(path, pattern);
	tcp.go();
}
#endif